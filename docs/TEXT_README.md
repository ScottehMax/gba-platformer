# Text Drawing System for GBA

## Overview
This system provides text rendering for GBA using the TinyPixie pixel font. It supports two rendering modes: **background-based text** (BG3) for efficient static/dynamic text, and **sprite-based text** (OAM) for small amounts of text that need to move freely.

## Features
- Variable-width font rendering
- ASCII printable characters (space through tilde, chars 32-126)
- 8×8 pixel tiles for GBA compatibility
- Background text system with text slot management
- Sprite text system for movable text
- Font data read directly from ROM (no VRAM waste)
- Configurable slot sizes and counts

## Files
- `text.h` / `text.c` - Text drawing API
- `tools/font_to_spritesheet.py` - TTF to PNG spritesheet converter
- `assets/tinypixie.png` - Generated font spritesheet (128×48 pixels, 16×6 grid)
- `assets/tinypixie_widths.h` - Character width metadata
- `generated/tinypixie.h` / `tinypixie.c` - Generated by grit from PNG

## Configuration (text.c)

```c
#define BG_TEXT_DYNAMIC_START 1   // Start tile in char block 1 for dynamic text
#define TEXT_SLOT_TILES 28        // Tiles per text slot (28 = 224 pixels max width)
#define MAX_TEXT_SLOTS 18         // Maximum number of text strings
#define FONT_TILE_START 512       // Sprite font tiles start (for sprite text mode)
#define FONT_PALETTE 1            // Font palette slot
```

## Setup

### 1. Font Conversion (already done)
Convert a TTF font to a pixel-perfect PNG spritesheet:
```bash
uv run --with=Pillow python tools/font_to_spritesheet.py TinyPixie2.ttf assets/tinypixie.png 6
```
This creates:
- `assets/tinypixie.png` - 128×48 spritesheet (magenta #FF00FF transparent)
- `assets/tinypixie_widths.h` - Character width data for variable-width rendering
- `assets/tinypixie_meta.json` - Metadata (for reference)

### 2. Build System Integration
The Makefile automatically processes the PNG with grit:
```makefile
$(GENDIR)/tinypixie.h: assets/tinypixie.png | $(GENDIR)
	$(GRIT) $< -gB4 -gt -gTFF00FF -ftc -o$(GENDIR)/tinypixie
```

### 3. Initialize in Your Code
```c
#include "text.h"

// In your initialization code:

// Load font palette to background palette slot 1 (colors 16-31)
volatile u16* bgPalette = MEM_BG_PALETTE;
for (int i = 0; i < 16; i++) {
    bgPalette[PALETTE_FONT * 16 + i] = tinypixiePal[i];
}

// Initialize background text system (BG3 - uses char block 1)
init_bg_text();
```

**Note:** Font tiles are NOT copied to VRAM. They're read directly from ROM (tinypixieTiles) and rendered into dynamic text tiles as needed. This saves ~3KB of VRAM.

## Background Text API (Recommended)

The background text system uses BG3 with dynamic tile generation. Text is rendered into VRAM tiles allocated from a slot pool.

### Initialize System
```c
void init_bg_text();
```
Sets up BG3 control register and clears the text layer.

### Draw Text with Automatic Slot Allocation
```c
int slot_id = draw_bg_text_auto("Hello World!", 1, 1);
// Returns: slot ID for later updates, or -1 if no slots available
```

**Parameters:**
- `str` - Text string to draw
- `tile_x, tile_y` - Position in tile coordinates (0-31)

**Returns:** Slot ID (0-17) or -1 if no slots available

### Update Text in Existing Slot
```c
void draw_bg_text_slot("Score: 1000", 1, 2, slot_id);
```
Updates the text in a previously allocated slot. More efficient than reallocating.

### Draw Text at Pixel Coordinates
```c
void draw_bg_text_px("Player 1", 120, 80);
```
Convenience function that converts pixel coordinates to tile coordinates.

### Free a Slot for Reuse
```c
void free_bg_text_slot(slot_id);
```
Marks a slot as free so it can be reused by another text string.

### Clear Text Layer
```c
void clear_bg_text();  // Clear entire 32x32 tilemap
void clear_bg_text_region(tile_x, tile_y, width, height);  // Clear specific region
```

### Memory Layout

- **BG3** uses character block 1 (CHAR_BLOCK(1)) and screen block 28 (SCREEN_BLOCK(28))
- Dynamic text tiles start at tile index `BG_TEXT_DYNAMIC_START` (default: 1)
- Each slot uses `TEXT_SLOT_TILES` tiles (default: 28 tiles = 224 pixels max width)
- Total VRAM used: `MAX_TEXT_SLOTS * TEXT_SLOT_TILES * 32 bytes` (default: 18 × 28 × 32 = 16KB)

## Sprite Text API (Optional)

The sprite text system uses OAM sprites for text that needs to move freely on screen. **Note:** This requires loading font tiles to sprite VRAM, which uses additional memory.

### Draw Sprite Text
```c
// Draw text at screen position (10, 20)
// Uses OAM sprite indices 100-119 (one sprite per character)
int sprites_used = draw_text("Hello!", 10, 20, 100);
```

**Parameters:**
- `str` - Text string to draw
- `x, y` - Screen coordinates in pixels (0-239, 0-159)
- `start_oam_index` - First OAM sprite index to use (0-127)

**Returns:** Number of OAM sprites used

### Draw Single Character
```c
int width = draw_char('A', 50, 50, 10);
// Returns: Character width in pixels
```

### Get Text Width
```c
int width = text_width("Score: 9999");
int centered_x = (SCREEN_WIDTH - width) / 2;
```

**Returns:** Total width in pixels (including character spacing)

### Setup for Sprite Text

If using sprite text, you must load font tiles to sprite VRAM:

```c
// Copy font tiles to sprite VRAM at tile 512
volatile u32* spriteTiles = MEM_SPRITE_TILES;
for (int i = 0; i < tinypixieTilesLen / 4; i++) {
    spriteTiles[FONT_TILE_START * 8 + i] = tinypixieTiles[i];
}

// Load font palette to sprite palette slot 1
volatile u16* spritePalette = MEM_SPRITE_PALETTE;
for (int i = 0; i < 16; i++) {
    spritePalette[16 + i] = tinypixiePal[i];
}
```

**VRAM cost:** 96 tiles × 32 bytes = 3KB sprite VRAM

## Example: Debug Info Display

```c
int main() {
    // ... initialization ...
    init_bg_text();

    char posXStr[32] = "X: 0";
    char posYStr[32] = "Y: 0";

    // Allocate text slots once
    draw_bg_text_auto("Debug Info", 1, 1);
    int posXSlot = draw_bg_text_auto(posXStr, 1, 2);
    int posYSlot = draw_bg_text_auto(posYStr, 1, 3);

    // Game loop
    while (1) {
        vsync();

        // Update debug info every frame (reuse slots)
        int posX = player.x >> FIXED_SHIFT;
        int posY = player.y >> FIXED_SHIFT;

        int_to_string(posX, posXStr, sizeof(posXStr), "X: ");
        draw_bg_text_slot(posXStr, 1, 2, posXSlot);

        int_to_string(posY, posYStr, sizeof(posYStr), "Y: ");
        draw_bg_text_slot(posYStr, 1, 3, posYSlot);
    }
}
```

## Important Notes

### Background Text
- **Efficient for static/semi-static text**: HUD elements, debug info, menus
- Uses tile-based coordinates (32x32 grid)
- Text slots can be reused to avoid allocation overhead
- Maximum `MAX_TEXT_SLOTS` strings can be displayed simultaneously
- Each slot supports up to `TEXT_SLOT_TILES * 8` pixels of text width

### Sprite Text
- **Better for moving text**: Floating damage numbers, speech bubbles
- Uses pixel coordinates for precise positioning
- Limited by OAM sprite count (128 total, must share with game objects)
- Each character uses 1 sprite
- Requires loading font tiles to sprite VRAM (3KB cost)

### Character Spacing
- Characters use variable width (2-7 pixels)
- Characters are rendered touching (no spacing) for compact text
- Space character (` `) is 3 pixels wide

### Performance
- Background text: Drawing every frame is fine, minimal overhead
- Sprite text: Drawing every frame is fine for small amounts
- For static text, draw once and reuse slots
- Updating existing slots is faster than reallocating

## Customization

### Change Slot Configuration
Edit `text.c`:
```c
#define TEXT_SLOT_TILES 20   // Tiles per slot (20 = 160px max width)
#define MAX_TEXT_SLOTS 10    // Number of text slots
```

### Change VRAM Layout
Edit `text.c`:
```c
#define BG_TEXT_DYNAMIC_START 96   // Start at tile 96 instead of tile 1
```

### Change Font Tile Start (Sprite Mode)
Edit `text.c`:
```c
#define FONT_TILE_START 512  // Change to avoid collision with other sprites
```

### Change Font Palette
Edit `text.c`:
```c
#define FONT_PALETTE 1  // Change to use different palette slot (0-15)
```

### Use a Different Font
1. Run the conversion script with your TTF file
2. Rebuild the project
3. All done! The system auto-updates

## Technical Details

### Font Spritesheet Layout
```
128 pixels wide × 48 pixels tall
16 chars per row × 6 rows = 96 character slots (95 used)
Each character: 8×8 pixels (1 GBA tile)
Grid: 16 tiles wide × 6 tiles tall = 96 tiles
```

### Supported Characters
```
ASCII 32-126: !"#$%&'()*+,-./0123456789:;<=>?@
              ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`
              abcdefghijklmnopqrstuvwxyz{|}~
```

### Character Width Table
Stored in `font_char_widths[]` array (see `assets/tinypixie_widths.h`)
- Smallest: 2 pixels (`,`, `i`, `j`, `l`, `!`, `|`)
- Largest: 7 pixels (`@`, `&`, `M`, `W`)
- Average: ~4 pixels

### How Dynamic Text Rendering Works

1. **Text is rasterized into a pixel buffer** using variable-width character data
2. **Pixel buffer is split into 8×8 tiles** and uploaded to VRAM
3. **Background map is updated** to display the tiles
4. **Font character tiles are read directly from ROM** (tinypixieTiles), not VRAM

This approach saves 3KB of VRAM compared to copying all 96 font characters to VRAM.

## Troubleshooting

### Background text doesn't appear
- Verify BG3 is enabled in REG_DISPCNT
- Check text coordinates are in range (0-31 tiles)
- Ensure font palette is loaded to palette bank 1
- Verify `init_bg_text()` was called

### Text appears as garbage
- Make sure font palette is loaded correctly
- Check that BG3 is using char block 1 and screen block 28
- Verify tinypixie data is compiled correctly

### Text is cut off
- Increase `TEXT_SLOT_TILES` if text exceeds slot width
- Text longer than `TEXT_SLOT_TILES * 8` pixels will be truncated

### Out of text slots
- Increase `MAX_TEXT_SLOTS` in text.c
- Free unused slots with `free_bg_text_slot()`
- Consider using `draw_bg_text_slot()` to reuse slots instead of reallocating

### Sprite text doesn't appear (if using sprite mode)
- Make sure font tiles are loaded to sprite VRAM at FONT_TILE_START
- Verify sprite palette is loaded correctly
- Check that sprites are enabled in REG_DISPCNT
- Ensure OAM indices don't exceed 127
